<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kbxtu.github.io/</id>
    <title>kuangbin</title>
    <updated>2020-08-05T08:46:25.954Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kbxtu.github.io/"/>
    <link rel="self" href="https://kbxtu.github.io/atom.xml"/>
    <subtitle>希望你比冬天先到</subtitle>
    <logo>https://kbxtu.github.io/images/avatar.png</logo>
    <icon>https://kbxtu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, kuangbin</rights>
    <entry>
        <title type="html"><![CDATA[洛谷 P1967 货车运输 NOIP2013]]></title>
        <id>https://kbxtu.github.io/post/luo-gu-p1967-huo-che-yun-shu-noip2013/</id>
        <link href="https://kbxtu.github.io/post/luo-gu-p1967-huo-che-yun-shu-noip2013/">
        </link>
        <updated>2020-08-05T08:24:08.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1967">传送门</a></p>
<h1 id="思路">思路</h1>
<p>首先建图，题目有重边，可建一棵最大生成树。给出的n有1e4，用floyd算法时间复杂度为n^3, 空间复杂度为n^2.因此需要用lca和树上倍增dp来做，如果询问的x，y不在一棵树上就输出-1，否则就跑个lca.</p>
<p>#代码</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
using namespace std;
#define inf 0x3f3f3f3f
#define ll long long
#define maxn 100005
#define mod 998244353
struct Edge{
    int to,next,w;
}edge[maxn];
struct e{
    int u,v,w;
}edge1[maxn];
int cnt,head[maxn],w[maxn][21],fa[maxn],f[maxn][21],n,m,dep[maxn];
void add_edge(int u,int v,int w){
    edge[cnt].to=v;
    edge[cnt].w=w;
    edge[cnt].next=head[u];
    head[u]=cnt++;
    edge[cnt].to=u;
    edge[cnt].w=w;
    edge[cnt].next=head[v];
    head[v]=cnt++;
}
bool cmp(e a,e b){
    return a.w&gt;b.w;
}
void init(){
    cnt=0; 
    for(int i=0;i&lt;=n;i++){
		head[i]=-1,fa[i]=i;
	} 
}
int find(int x){
    return fa[x]==x?x:(fa[x]=find(fa[x]));
}
int lca(int x,int y){
    int i,ans=inf;
    if(dep[x]&gt;dep[y]) swap(x,y);
    for(i=20;i&gt;=0;i--){
        if(dep[f[y][i]]&gt;=dep[x]) ans=min(ans,w[y][i]),y=f[y][i];
        if(x==y) return ans;
    }
    for(i=20;i&gt;=0;i--){
        if(f[x][i]!=f[y][i]){
            ans=min(ans,min(w[x][i],w[y][i]));
            x=f[x][i],y=f[y][i];
        }
    }
    return min(ans,min(w[x][0],w[y][0]));
}
void build(){
    for(int i=1;i&lt;=m;i++){
        int u=edge1[i].u,v=edge1[i].v;
        int fu=find(u),fv=find(v);
        if(fu==fv) continue;
        add_edge(u,v,edge1[i].w);
        fa[fv]=fu;
    }
}
void dfs(int x){
    int i,j;
    for(i=head[x];i!=-1;i=edge[i].next){
        int v=edge[i].to,ww=edge[i].w;
        if(dep[v]) continue;
        dep[v]=dep[x]+1;
		w[v][0]=ww;
		f[v][0]=x;
        for(j=1;(1&lt;&lt;j)&lt;dep[v];j++) f[v][j]=f[f[v][j-1]][j-1],w[v][j]=min(w[v][j-1],w[f[v][j-1]][j-1]);
        dfs(v);
    }
}

int main(){
    int i, j, k, t;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int u, v;
    init();
    for(i=1;i&lt;=m;i++)
        scanf(&quot;%d%d%d&quot;,&amp;edge1[i].u,&amp;edge1[i].v,&amp;edge1[i].w);
    sort(edge1+1,edge1+m+1,cmp);
    build();
    for(i=1;i&lt;=n;i++){
        if(dep[i]) continue;
        dep[i]=1;
        dfs(i);
    }
    scanf(&quot;%d&quot;,&amp;t);
    while(t--){
        scanf(&quot;%d %d&quot;,&amp;u,&amp;v);
        if(find(u)!=find(v)){
            printf(&quot;-1\n&quot;);
            continue;
        }
        printf(&quot;%d\n&quot;,lca(u,v));
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Round #659 (Div. 2) B2 - Koa and the Beach (Hard Version)]]></title>
        <id>https://kbxtu.github.io/post/codeforces-round-659-div-2-b2-koa-and-the-beach-hard-version/</id>
        <link href="https://kbxtu.github.io/post/codeforces-round-659-div-2-b2-koa-and-the-beach-hard-version/">
        </link>
        <updated>2020-08-02T13:18:18.000Z</updated>
        <content type="html"><![CDATA[<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=3e5+5;
int a[N];
void solve(){
	int n,k,l,i;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;l);
	a[0]=a[n+1]=k+1;
	for(i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]),
		a[i]=l-a[i];//a数组存放上涨a[i]后依然能通过
	int w=k+1,f=-1;//w表示当前潮汐高度f表示下一秒潮汐变化的数字
	for(i=1;i&lt;=n;i++){
		if(a[i]&lt;0){printf(&quot;No\n&quot;);return;}//无法通过
		else if(a[i]&gt;=k)w=k+1,f=-1;//若潮汐在最高处时这个点还是安全的，可以在这个点等到潮最高时
		else if(f==-1)w=min(w+f,a[i]);//只要当前是潮落的状态就可以等待
		else{w+=f;if(w&gt;a[i]){printf(&quot;No\n&quot;);return;}}//若是涨潮状态这个点已经不安全了则说明这个点无法通过
		if(w==0)f=1;
	}
	printf(&quot;Yes\n&quot;);
}
 
int main(){
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)solve();
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020牛客多校第一场 I 1 or 2]]></title>
        <id>https://kbxtu.github.io/post/2020-niu-ke-duo-xiao-di-yi-chang-i-1-or-2/</id>
        <link href="https://kbxtu.github.io/post/2020-niu-ke-duo-xiao-di-yi-chang-i-1-or-2/">
        </link>
        <updated>2020-07-15T01:57:58.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5666/I">传送门</a></p>
<h1 id="题意">题意</h1>
<p>给你一个图，问其是否有一个子图使得每个点的度恰好为指定的度。</p>
<h1 id="思路">思路</h1>
<p>此题有两种解法，一种是正统的带花树解法，还有一种是网络流。</p>
<h2 id="1">1</h2>
<p>带花树用于一般图的最大匹配，比起二分图，一般图多出了环，所以我们只需要考虑环的处理，如果是偶环不会影响正常求解，只需要考虑奇环的情况，为什么呢。<br>
我们在寻找增广路的时候，会将路径上的点黑白染色，匹配只存在黑点与白点之间。<br>
如果没有环或者只有偶环，那么每个点的颜色（或者说奇偶性）是确定的<br>
但如果出现了奇环，那么点的颜色就不再确定，因为奇环顺时针走一圈和逆时针走一圈的结果是不同的。<br>
带花树算法仍然是从每个未匹配的点开始寻找增广路，不过我们采用BFS的方式，每个点均设为无色，端点染成黑色<br>
设当前点为u（黑色）,枚举与它相邻的点v<br>
考虑v是否已经被访问过：<br>
若v尚未访问过（v为无色）<br>
如果v尚未匹配，说明我们找到了一条增广路，直接返回修改。<br>
如果v已经匹配，那么将v染成白色，v的匹配点x加入队列，继续寻找增广路，x染成黑色。<br>
容易看出，根据上面的过程，我们只会对于黑点枚举出边，正确性是显然的，并且我们访问的路径形成了一棵黑白点交错的树。<br>
若v已经访问过（有颜色），说明我们找到了一个环。<br>
如果它是一个偶环（v为白色），那么v显然已经被找过了，无需再找一次。<br>
如果它是一个奇环（v为黑色），就需要采用带花树的特殊处理了。<br>
<img src="https://img-blog.csdnimg.cn/20190319210715147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ajEwNTQ2ODk2OTk=,size_16,color_FFFFFF,t_70" alt="奇环" loading="lazy"><br>
如上图，粗边为匹配边。<br>
对于一个奇环，我们一定是从一个黑点进入，然后也在黑点碰头(u,v)，（这个可以画图理解一下，如果不是从黑点进入，我们在之前访问这个奇环时一定还没有绕一圈就找到增广路增广了）<br>
问题在于，此时对于整个奇环的颜色都不确定了，我们令这个奇环的顶点为最顶上的那一个黑点，那么考虑u上方的这一个白点，我们既可以走从顶点走一条非匹配边到它，它作为一个黑点，也可以从另一边转一圈到它，此时这个它变成了黑点，它是需要加入队列继续走的<br>
也就是说，对于一个奇环，它上面的点都可以成为黑点。<br>
继续观察可以发现，整个奇环的匹配状态只与顶点的匹配状态有关，如果在后来的某一次寻找时奇环上的匹配被改变了，那么顶点的颜色唯一决定了整个环的匹配边是如何走的。<br>
也就是说，整个环就可以用一个顶点表示了，也就意味着我们可以将这个环缩掉，缩掉的环就称为“花”，缩环就是开花<br>
我们不妨对于每一个白点x，记pre[x]表示x是由哪一个黑点走过来的，也就是记录了增广路上的非匹配边。<br>
对于每一个点，记match[x]表示x的匹配点是谁。<br>
缩环具体怎么缩呢？<br>
如果直接修改原本的连边比较麻烦，我们考虑采用并查集，记录每个点所在的奇环的顶点，初始时就是它自己。缩环的时候，我们直接将环上的所有点并查集父亲连向奇环的顶点，并将环上的白点都变成黑点，并且加入队列。<br>
此外，由于奇环可以双向走，因此我们的pre边也要变成双向的。<br>
容易发现，我们有可能经过了多次缩环，也就是说某一次缩环的一个点很有可能是缩过的一个环顶，我们在缩环以及找到增广路返回修改的时候是需要走原来缩之前的环的，这个只需要沿着pre和match一直走即可，pre在这里相当于记录了缩掉的环内部的走法。<br>
现在我们来理一理思路<br>
从每个未匹配的点BFS寻找增广路，每个点均设为无色，端点染成黑色<br>
枚举与当前点u（黑色）相邻的点v<br>
考虑v是否已经被访问过<br>
若v尚未访问过（v为无色）<br>
如果v尚未匹配，找到了一条增广路，直接返回修改。<br>
如果v已经匹配，将v染成白色，将v的匹配点x加入队列，继续寻找增广路，x染成黑色。<br>
若v在当次增广已经访问过，找到环<br>
v为白色，是一个偶环，跳过。<br>
v为黑色且u,v所在的奇环已经缩过了，那么也跳过。<br>
否则，v为黑色，找到一个新的奇环，那么找到u,v所在奇环的环顶（即它们在BFS上跑出来的交错树的lca，称之为最近公共花祖先），将u到环顶的路径以及v到环顶的路径修改掉，白点染成黑点，加入队列，并将环上的点（或者是某个已经缩了的环顶）并查集父亲指向lca。<br>
上面就是带花树的一些解释了，这里参考了很多博客才理解的，上面内容也是取自这些博客。</p>
<p>关于这个题其实也有原题<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3551">hdu3551</a>,比较有技巧的地方就是建图，把每个点都拆分成题目所要求的度数个点（我们暂且称这些点为分点），把每条边也拆成两个点，例如边（u，v）拆成点两个点a，b，a与u的所有分点相连，b与v的所有分点相连。a，b也连一条边。建好图后求一个完美匹配即可，为什么是完美匹配呢，因为对于每一个点u，如果其分点都能匹配到，则匹配的相应边的另一点也能与另一点的分点匹配，而没有与分点匹配的边的两个点会自己与自己匹配。这样找到的一个完美匹配就是答案。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

typedef pair&lt;int, int&gt; PII;
typedef long long LL;
const int N = 110, M = 410;
vector&lt;int&gt; e[N];
int n, m;
int d[N];
int idx;
PII edge[N];
vector&lt;int&gt; du[N];

bool Graph[M][M];
int Match[M];
bool InQueue[M], InPath[M], InBlossom[M];
int Head, Tail;
int Queue[M];
int Start, Finish;
int NewBase;
int Father[M], Base[M];
int Count;

void init() {
    for(int i = 1; i &lt;= n; i++) {
        e[i].clear();
        du[i].clear();
    }
    memset(d, 0, sizeof d);
    memset(edge, 0, sizeof edge);
    memset(Graph, 0, sizeof Graph);
    memset(Match, 0, sizeof Match);
    memset(InQueue, 0, sizeof InQueue);
    memset(InPath, 0, sizeof InPath);
    memset(InBlossom, 0, sizeof InBlossom);
    memset(Queue, 0, sizeof Queue);
    memset(Father, 0, sizeof Father);
    memset(Base, 0, sizeof Base);
    Count = Start = Finish = NewBase = Head = Tail = idx = 0;
}

void CreatGraph() {//建图
    for(int i = 1; i &lt;= n; i++) {
        for(int j = 1; j &lt;= d[i]; j++) {
            du[i].push_back(++idx);
        }
    }
    for(int i = 1; i &lt;= m; i++) {
        int u = edge[i].first, v = edge[i].second;
        int a = ++idx, b = ++idx;
        Graph[a][b] = Graph[b][a] = 1;
        for(int j = 0; j &lt; du[u].size(); j++) {
            int x = du[u][j];
            Graph[a][x] = Graph[x][a] = 1;
        }
        for(int j = 0; j &lt; du[v].size(); j++) {
            int x = du[v][j];
            Graph[b][x] = Graph[x][b] = 1;
        }
    }
}


void Push(int u) {
    Queue[Tail] = u;
    Tail++;
    InQueue[u] = true;
}

int Pop() {
    int res = Queue[Head];
    Head++;
    return res;
}
//下面都是带花树模板
int FindCommonAncestor(int u, int v) {//寻找最近公共花祖先lca
    memset(InPath, false, sizeof(InPath));
    while(true) {
        u = Base[u];
        InPath[u] = true;
        if(u == Start) break;
        u = Father[Match[u]];
    }
    while(true) {
        v = Base[v];
        if(InPath[v]) break;
        v = Father[Match[v]];
    }
    return v;
}

void ResetTrace(int u) {
    int v;
    while(Base[u] != NewBase) {
        v = Match[u];
        InBlossom[Base[u]] = InBlossom[Base[v]] = true;
        u = Father[v];
        if(Base[u] != NewBase) Father[u] = v;
    }
}

void BloosomContract(int u, int v) {
    NewBase = FindCommonAncestor(u, v);
    memset(InBlossom, false, sizeof(InBlossom));
    ResetTrace(u);
    ResetTrace(v);
    if(Base[u] != NewBase) Father[u] = v;
    if(Base[v] != NewBase) Father[v] = u;
    for(int tu = 1; tu &lt;= idx; tu++) {
        if(InBlossom[Base[tu]]) {
            Base[tu] = NewBase;
            if(!InQueue[tu]) Push(tu);
        }
    }
}

void FindAugmentingPath() {
    memset(InQueue, false, sizeof(InQueue));
    memset(Father, 0, sizeof Father);
    for(int i = 1; i &lt;= idx; i++) Base[i] = i;
    Head = Tail = 1;
    Push(Start);
    Finish = 0;
    while(Head &lt; Tail) {
        int u = Pop();
        for(int v = 1; v &lt;= idx; v++) {

            if(Graph[u][v] &amp;&amp; (Base[u] != Base[v]) &amp;&amp; (Match[u] != v)) {

                if((v == Start) || ((Match[v] &gt; 0) &amp;&amp; Father[Match[v]] &gt; 0)) {
                    BloosomContract(u, v);
                }
                else if(Father[v] == 0) {
                    Father[v] = u;
                    if(Match[v] &gt; 0) Push(Match[v]);
                    else {
                        Finish = v;
                        return;
                    }
                }
            }
        }
    }
}

void AugmentPath() {
    int u, v, w;
    u = Finish;
    while(u &gt; 0) {
        v = Father[u];
        w = Match[v];
        Match[v] = u;
        Match[u] = v;
        u = w;
    }
}

void Edmonds() {
    memset(Match, 0, sizeof Match);
    for(int u = 1; u &lt;= idx; u++) {
        if(Match[u] == 0) {
            Start = u;
            FindAugmentingPath();
            if(Finish &gt; 0) AugmentPath();
        }
    }
}

void PrintMatch() {
    Count = 0;
    for(int u = 1; u &lt;= idx; u++) {
        if(Match[u] &gt; 0) Count++;
    }
    if(Count == idx) puts(&quot;Yes&quot;);
    else puts(&quot;No&quot;);
}

void solve() {
    CreatGraph();
    Edmonds();
    PrintMatch();
}

int main() {
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) {
        init();
        for(int i = 1; i &lt;= n; i++) {
            scanf(&quot;%d&quot;, &amp;d[i]);
        }
        for(int i = 1; i &lt;= m; i++) {
            int u, v;
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            e[u].push_back(v);
            e[v].push_back(u);
            edge[i] = {u, v};
        }
        solve();
    }
    return 0;
}

</code></pre>
<h2 id="2">2</h2>
<p>第二种方法虽然不是正解，也提一下，利用一个超级源点和超级汇点，点与点建边，每个点拆成i和i'，源点和i连一条权值为di的边，i'和汇点连一条权值为di的边，对于m条边，u和v，u于v'建边，v与u'建边，这样每个点的流量都只能流到其他点，最大流就是让每个点都选了di条边。如果流出源点和流入汇点的值相等则判断是合理的。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
#define INF 0x3f3f3f3f
using namespace std;
struct EDGE {
	int to, w, next;
} edge[2000];
int cnt;
int head[2000];
int deep[2000];

void init() {
	cnt = 0;
	memset(head, -1, sizeof(head));
}

void addedge(int u, int v, int w) {
	edge[cnt].to=v; edge[cnt].w=w; edge[cnt].next=head[u]; head[u]=cnt++;
	edge[cnt].to=u; edge[cnt].w=0; edge[cnt].next=head[v]; head[v]=cnt++;
}

int bfs(int s, int t) {
	queue&lt;int&gt; q;
	memset(deep, 0, sizeof(deep));
	q.push(s);
	deep[s] = 1;
	int top;
	while(!q.empty()) {
		top = q.front();
		q.pop();
		for(int i = head[top];i+1; i = edge[i].next) {
			int v = edge[i].to;
			int w = edge[i].w;
			if(!deep[v]&amp;&amp;w) {
				deep[v] = deep[top]+1;
				q.push(v);
			}
		}
	}
	return deep[t];
}

int dfs(int s, int t, int inflow) {
	if(s==t) return inflow;
	int acflow=0;
	for(int i=head[s]; i+1; i=edge[i].next) {
		if(edge[i].w &amp;&amp; deep[s]+1 == deep[edge[i].to]) {
			int x = dfs(edge[i].to,t,min(inflow, edge[i].w));
			if(x&gt;0) {
				acflow+=x; inflow-=x;edge[i].w -= x; edge[i^1].w += x;
				if(!inflow) break;
			}
		}
	}
	if(!acflow) deep[s] = -2;
	return acflow;
}

int dinic(int s,int t) {
	int f = 0;
	while(bfs(s,t)) f += dfs(s,t,INF);
	return f;
}

int n, m, a, b;
int d[55];

int main() {
	while(~scanf(&quot;%d %d&quot;, &amp;n, &amp;m)) {
		init();
		int sum = 0;
		for(int i = 1;i &lt;= n; i++) {
			scanf(&quot;%d&quot;, &amp;d[i]);
			sum += d[i];
			addedge(0, i, d[i]);
		}
		
		int l = 1e9, r = 0;
		for(int i = 1;i &lt;= m; i++) {
			scanf(&quot;%d %d&quot;, &amp;a, &amp;b);
			addedge(a, b+n, 1);
			l = min(l, b+n); r = max(r, b+n);
			addedge(b, a+n, 1);
			l = min(l, a+n); r = max(r, a+n);
		}
		
		int fin = r+1;
		for(int i = l;i &lt;= r; i++) {
			addedge(i, fin, d[i-n]);
		}
		
		printf(&quot;%s\n&quot;, dinic(0, fin)==sum?&quot;Yes&quot;:&quot;No&quot;);
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Educational Codeforces Round 89 (Rated for Div. 2) E. Two Arrays]]></title>
        <id>https://kbxtu.github.io/post/educational-codeforces-round-89-rated-for-div-2-e-two-arrays/</id>
        <link href="https://kbxtu.github.io/post/educational-codeforces-round-89-rated-for-div-2-e-two-arrays/">
        </link>
        <updated>2020-07-08T10:02:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题意">题意</h1>
<p>出一个长度为 n 的序列 a ，再给出一个长度为 m 的序列 b ，题目保证序列 b 是严格递增的，我们需要将 a 分割成恰好 m 段，使得每一段的最小值恰好等于 b[ i ] ，问有多少种分割方法<br>
#思路<br>
如果知道每一段的左右区间的取值范围后，根据乘法原理不难算出答案，但又因为每一段的左端点和右端点都是不断变化的，看似不太好直接求解，仔细分析一下不难看出，因为相邻的两段之间是拼接而成的，所以上一段的终点，也就决定了下一段的起点，反之亦然，又因为序列 b 是严格递增的，且需要求的是序列 a 中的最小值，所以倒着处理比较方便，这样一来我们就可以求出每一个 b[ i ] 对应在序列 a 上的起点的左右区间，然后利用乘法原理计算答案就好了。<br>
举个例子，就拿样例 1 来说：序列 a 为 { 12 10 20 20 25 30 } ，序列 b 为 { 10 20 30 }倒着来看的话，如果想要让 min( a[ l ] : a[ r ] ) = b[ 3 ] 的话，只能在序列 a 中取 [ 6 , 6 ] 这段区间，这样一来，b[ 2 ] 终点的位置就确定为 5 了，看一下 b[ 2 ] 的起点，可以选择 3 也可以选择 4 ，即在序列 a 中选择区间 [ 3 , 5 ] 和 [ 4 , 5 ] 都可以满足 min( al : ar ) = b[ 2 ] ，此时因为 b[ 1 ] 的起点一定是位置 1 ，而 b[ 1 ] 的终点已经由 b[ 2 ] 的起点决定了，所以这个样例的答案为 2 。<br>
到这里可能会有一个疑问，假如 b[ k + 1 ] 起点的选择范围是 [ x , y ] ，b[ k ] 当前选择的起点为 z ，正常来说当 b[ k + 1 ] 这段选择的起点为 x 时，b[ k ] 这段选择的区间是 [ z : x - 1 ] ，这里的 min( a[ z ] : a[ x - 1 ] ) = b[ k ] 是显然的，那么当 b[ k + 1 ] 这段如果选择的起点是 x + 1 时，如何保证 min( a[ z ] : a[ x ] ) 这段也是 b[ k ] 呢？因为之前 a[ x ] 这个元素包含在 b[ k + 1 ] 这段中，所以 a[ x ] &gt;= b[ k + 1 ] ，又因为 b[ k + 1 ] &gt; b[ k ] (已知条件)，所以 a[ x ] &gt;= b[ k + 1 ] &gt; b[ k ] ，所以 min( a[ z ] : a[ x ] ) = min( min( a[ z ] : a[ x - 1 ] ) , a[ z ] ) = min( b[ k ] , a[ x ] ) = b[ k ]说道这里就可以想到维护一个最小值的后缀然后判断了，设 mmin[ i ] = min( a[ i ] : a[ n ] ) ，根据上面的那一段可知，如果我们处理到了第 k 个位置，也就是需要处理第 b[ k ] 段的区间，只要 [ k + 1 , m ] 这些区间都合法的话，那么 mmin[ i ] = b[ k ] 的这些位置都是可以在第 k 段上当做起点的位置，且是连续的，因为数据比较大，所以用 map 离散的记一下数</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;string&gt;
#include&lt;ctime&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
using namespace std;
typedef long long LL;
const int inf=0x3f3f3f3f;
const int N=2e5+100;
const int mod=998244353;
int a[N],b[N];
int mmin[N];
map&lt;int,int&gt;cnt;
int main()
{
	int n,m;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,a+i);
	for(int i=1;i&lt;=m;i++)
		scanf(&quot;%d&quot;,b+i);
	mmin[n+1]=inf;
	for(int i=n;i&gt;=1;i--)
	{
		mmin[i]=min(mmin[i+1],a[i]);
		cnt[mmin[i]]++;
	}
	if(mmin[1]!=b[1])
		return 0*puts(&quot;0&quot;);
	LL ans=1;
	for(int i=2;i&lt;=m;i++)
		ans=ans*cnt[b[i]]%mod;
	printf(&quot;%lld\n&quot;,ans);
    return 0;
}
</code></pre>
<p>自己的解法，没想到维护后缀。记录每个b[i]最后出现的位置，从后往前计数，由于b是严格递增的，不需要担心位置重叠问题。但这个方法特判比较多，不像上面那个方法。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
using namespace std;
#define inf 0x7fffffff
#define ll long long
#define maxn 200005
#define mod (998244353)
ll a[maxn], b[maxn], r[maxn];
int main(){
    ll i, n, j, k, t, m, ans=1;
    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);
    for(i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]);
    for(i=1;i&lt;=m;i++) scanf(&quot;%lld&quot;,&amp;b[i]);
    if(m==1){
    	bool f=false;
    	for(i=n;i&gt;=1;i--){
    		if(a[i]&lt;b[1]){
				printf(&quot;0\n&quot;);
				return 0;
			}
			if(a[i]==b[1]) f=true;
		}
		if(f)
		printf(&quot;1\n&quot;);
		else printf(&quot;0\n&quot;);
			return 0;
	}
    ll cur=m;
    for(i=n;i&gt;=1;i--) 
		if(a[i]==b[cur]) r[cur--]=i;
    if(cur){
        printf(&quot;0\n&quot;);
        return 0;
    }
    for(i=r[1];i&gt;=1;i--)
        if(a[i]&lt;b[1]){
            printf(&quot;0\n&quot;);
            return 0;
        }
    for(j=n;j&gt;r[m];j--)
        if(a[j]&lt;b[m]){
            printf(&quot;0\n&quot;);
            return 0;
        }
    for(i=m;i&gt;1;i--){
        for(j=r[i];j&gt;r[i-1];j--) if(a[j]&lt;b[i]) break;
        if(a[j]&lt;a[r[i-1]]){
        	printf(&quot;0\n&quot;);
            return 0;
		} 
        ans=ans*(r[i]-j)%mod;
    }
    printf(&quot;%lld\n&quot;,ans);
}

···
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Round #654 (Div. 2) E Asterism]]></title>
        <id>https://kbxtu.github.io/post/test-one/</id>
        <link href="https://kbxtu.github.io/post/test-one/">
        </link>
        <updated>2020-07-07T04:29:41.000Z</updated>
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1371/problem/E1">传送门</a></p>
<h1 id="题意">题意</h1>
<p>给定长度为n的数组a，表示有n个敌人，第i个敌人有ai颗糖<br>
定义f(x)为：<br>
一开始你有x颗糖，对于长度为n的所有排列，都按照排列的顺序去打敌人当你的糖数量&gt;=怪物的糖数量，那么可以打败敌人，且打败之后你的糖数量+1，f(x)的值就是满足条件的排列数，现在给定一个质数p，要求你找出所有的x，满足f(x)%p!=0<br>
简单版本保证不超过2000<br>
困难版本保证满足条件的x的数量不超过1e5<br>
数据范围：n&lt;=1e5，1&lt;=a(i)&lt;=1e9</p>
<h1 id="e1">E1</h1>
<p>对于简单版本，可以考虑o(n^2)的做法。<br>
设数组a里面的最大值为m，当x&gt;=m时，排列方式为n!，因为p小于等于n，故不满足f(x)%p!=0<br>
当x&lt; m-n+1时，x不能打败最后一个敌人f(x)=0。故m-n+1&lt;=x&lt; m,对a排序后依次判断即可</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
using namespace std;
#define inf 0x7fffffff
#define ll long long
vector&lt;int&gt; ans;
int a[3000],n,p;

int f(int x){
    int ans=1,cur=1;
    for(int i=1;i&lt;=n;i++){
    	for(;cur&lt;=n;cur++){
    		if(x&lt;a[cur]){
            	break;
        	}
		} 
        if((cur-i)%p==0)return 0;
        x++;
    }
    return ans;
}

int main(){
    int i, j, k, t, m;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;p);
    m=0;
    for(i=1;i&lt;=n;i++){
        scanf(&quot;%d&quot;,&amp;a[i]);
    }
    sort(a+1,a+1+n);m=a[n];
    for(i=max(1,m-n+1);i&lt;m;i++){
        if(f(i)) ans.push_back(i);
    }
    k=ans.size();
    printf(&quot;%d\n&quot;,k);
    for(i=0;i&lt;k;i++){
        printf(&quot;%d &quot;,ans[i]);
    }
    printf(&quot;\n&quot;);
}

</code></pre>
<h1 id="e2">E2</h1>
<p>仔细思考可以发现符合条件的x都是连在一起的，即在同一个区间，因为对于排序后的每一个ai，x必须大于等于a[i]-i+1（打败i-1个敌人后能够达到a[i]），故x=max(x,a[i]-i+1),i=1~n。然后由于排列数不能为p的倍数，故每次可排序的数都要小于p,即当x满足a[i]-i+1时，x必须小于a[i+p-1]-i+1，故x=min(x,a[i+p-1]-(i-1)-1)。复杂度为o(n)。</p>
<pre><code>C++
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
using namespace std;
#define inf 0x7fffffff
#define ll long long
ll n, m, p, a[100006];
int main(){
    ll i, j, k, t;
    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;p);
    for(i=1;i&lt;=n;i++){
        scanf(&quot;%lld&quot;,&amp;a[i]);
    }
    ll l=1,r=1e9;
    for(i=1;i&lt;=n;i++) l=max(l,a[i]-i+1);
    for(i=1;i+p-1&lt;=n;i++) r=min(r,a[i+p-1]-i);
    if(l&gt;r) printf(&quot;0\n&quot;);
    else{
        printf(&quot;%lld&quot;,r-l+1);
        for(i=l;i&lt;=r;i++) printf(&quot;%lld &quot;,i);
        printf(&quot;\n&quot;);
    }
}
</code></pre>
]]></content>
    </entry>
</feed>