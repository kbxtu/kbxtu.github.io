<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kbxtu.github.io/</id>
    <title>kuangbin</title>
    <updated>2020-07-07T08:15:41.371Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kbxtu.github.io/"/>
    <link rel="self" href="https://kbxtu.github.io/atom.xml"/>
    <subtitle>希望你比冬天先到</subtitle>
    <logo>https://kbxtu.github.io/images/avatar.png</logo>
    <icon>https://kbxtu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, kuangbin</rights>
    <entry>
        <title type="html"><![CDATA[Codeforces Round #654 (Div. 2) E Asterism]]></title>
        <id>https://kbxtu.github.io/post/test-one/</id>
        <link href="https://kbxtu.github.io/post/test-one/">
        </link>
        <updated>2020-07-07T04:29:41.000Z</updated>
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1371/problem/E1">传送门</a></p>
<h1 id="题意">题意</h1>
<p>给定长度为n的数组a，表示有n个敌人，第i个敌人有ai颗糖<br>
定义f(x)为：<br>
一开始你有x颗糖，对于长度为n的所有排列，都按照排列的顺序去打敌人当你的糖数量&gt;=怪物的糖数量，那么可以打败敌人，且打败之后你的糖数量+1，f(x)的值就是满足条件的排列数，现在给定一个质数p，要求你找出所有的x，满足f(x)%p!=0<br>
简单版本保证不超过2000<br>
困难版本保证满足条件的x的数量不超过1e5<br>
数据范围：n&lt;=1e5，1&lt;=a(i)&lt;=1e9</p>
<h1 id="e1">E1</h1>
<p>对于简单版本，可以考虑o(n^2)的做法。<br>
设数组a里面的最大值为m，当x&gt;=m时，排列方式为n!，因为p小于等于n，故不满足f(x)%p!=0<br>
当x&lt; m-n+1时，x不能打败最后一个敌人f(x)=0。故m-n+1&lt;=x&lt; m,对a排序后依次判断即可</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
using namespace std;
#define inf 0x7fffffff
#define ll long long
vector&lt;int&gt; ans;
int a[3000],n,p;

int f(int x){
    int ans=1,cur=1;
    for(int i=1;i&lt;=n;i++){
    	for(;cur&lt;=n;cur++){
    		if(x&lt;a[cur]){
            	break;
        	}
		} 
        if((cur-i)%p==0)return 0;
        x++;
    }
    return ans;
}

int main(){
    int i, j, k, t, m;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;p);
    m=0;
    for(i=1;i&lt;=n;i++){
        scanf(&quot;%d&quot;,&amp;a[i]);
    }
    sort(a+1,a+1+n);m=a[n];
    for(i=max(1,m-n+1);i&lt;m;i++){
        if(f(i)) ans.push_back(i);
    }
    k=ans.size();
    printf(&quot;%d\n&quot;,k);
    for(i=0;i&lt;k;i++){
        printf(&quot;%d &quot;,ans[i]);
    }
    printf(&quot;\n&quot;);
}

</code></pre>
<h1 id="e2">E2</h1>
<p>仔细思考可以发现符合条件的x都是连在一起的，即在同一个区间，因为对于排序后的每一个ai，x必须大于等于a[i]-i+1（打败i-1个敌人后能够达到a[i]），故x=max(x,a[i]-i+1),i=1~n。然后由于排列数不能为p的倍数，故每次可排序的数都要小于p,即当x满足a[i]-i+1时，x必须小于a[i+p-1]-i+1，故x=min(x,a[i+p-1]-(i-1)-1)。复杂度为o(n)。</p>
<pre><code>C++
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
using namespace std;
#define inf 0x7fffffff
#define ll long long
ll n, m, p, a[100006];
int main(){
    ll i, j, k, t;
    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;p);
    for(i=1;i&lt;=n;i++){
        scanf(&quot;%lld&quot;,&amp;a[i]);
    }
    ll l=1,r=1e9;
    for(i=1;i&lt;=n;i++) l=max(l,a[i]-i+1);
    for(i=1;i+p-1&lt;=n;i++) r=min(r,a[i+p-1]-i);
    if(l&gt;r) printf(&quot;0\n&quot;);
    else{
        printf(&quot;%lld&quot;,r-l+1);
        for(i=l;i&lt;=r;i++) printf(&quot;%lld &quot;,i);
        printf(&quot;\n&quot;);
    }
}
</code></pre>
]]></content>
    </entry>
</feed>