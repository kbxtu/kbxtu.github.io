<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kbxtu.github.io/</id>
    <title>kuangbin</title>
    <updated>2020-07-08T10:36:32.319Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kbxtu.github.io/"/>
    <link rel="self" href="https://kbxtu.github.io/atom.xml"/>
    <subtitle>希望你比冬天先到</subtitle>
    <logo>https://kbxtu.github.io/images/avatar.png</logo>
    <icon>https://kbxtu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, kuangbin</rights>
    <entry>
        <title type="html"><![CDATA[Educational Codeforces Round 89 (Rated for Div. 2) E. Two Arrays]]></title>
        <id>https://kbxtu.github.io/post/educational-codeforces-round-89-rated-for-div-2-e-two-arrays/</id>
        <link href="https://kbxtu.github.io/post/educational-codeforces-round-89-rated-for-div-2-e-two-arrays/">
        </link>
        <updated>2020-07-08T10:02:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题意">题意</h1>
<p>出一个长度为 n 的序列 a ，再给出一个长度为 m 的序列 b ，题目保证序列 b 是严格递增的，我们需要将 a 分割成恰好 m 段，使得每一段的最小值恰好等于 b[ i ] ，问有多少种分割方法<br>
#思路<br>
如果知道每一段的左右区间的取值范围后，根据乘法原理不难算出答案，但又因为每一段的左端点和右端点都是不断变化的，看似不太好直接求解，仔细分析一下不难看出，因为相邻的两段之间是拼接而成的，所以上一段的终点，也就决定了下一段的起点，反之亦然，又因为序列 b 是严格递增的，且需要求的是序列 a 中的最小值，所以倒着处理比较方便，这样一来我们就可以求出每一个 b[ i ] 对应在序列 a 上的起点的左右区间，然后利用乘法原理计算答案就好了。<br>
举个例子，就拿样例 1 来说：序列 a 为 { 12 10 20 20 25 30 } ，序列 b 为 { 10 20 30 }倒着来看的话，如果想要让 min( a[ l ] : a[ r ] ) = b[ 3 ] 的话，只能在序列 a 中取 [ 6 , 6 ] 这段区间，这样一来，b[ 2 ] 终点的位置就确定为 5 了，看一下 b[ 2 ] 的起点，可以选择 3 也可以选择 4 ，即在序列 a 中选择区间 [ 3 , 5 ] 和 [ 4 , 5 ] 都可以满足 min( al : ar ) = b[ 2 ] ，此时因为 b[ 1 ] 的起点一定是位置 1 ，而 b[ 1 ] 的终点已经由 b[ 2 ] 的起点决定了，所以这个样例的答案为 2 。<br>
到这里可能会有一个疑问，假如 b[ k + 1 ] 起点的选择范围是 [ x , y ] ，b[ k ] 当前选择的起点为 z ，正常来说当 b[ k + 1 ] 这段选择的起点为 x 时，b[ k ] 这段选择的区间是 [ z : x - 1 ] ，这里的 min( a[ z ] : a[ x - 1 ] ) = b[ k ] 是显然的，那么当 b[ k + 1 ] 这段如果选择的起点是 x + 1 时，如何保证 min( a[ z ] : a[ x ] ) 这段也是 b[ k ] 呢？因为之前 a[ x ] 这个元素包含在 b[ k + 1 ] 这段中，所以 a[ x ] &gt;= b[ k + 1 ] ，又因为 b[ k + 1 ] &gt; b[ k ] (已知条件)，所以 a[ x ] &gt;= b[ k + 1 ] &gt; b[ k ] ，所以 min( a[ z ] : a[ x ] ) = min( min( a[ z ] : a[ x - 1 ] ) , a[ z ] ) = min( b[ k ] , a[ x ] ) = b[ k ]说道这里就可以想到维护一个最小值的后缀然后判断了，设 mmin[ i ] = min( a[ i ] : a[ n ] ) ，根据上面的那一段可知，如果我们处理到了第 k 个位置，也就是需要处理第 b[ k ] 段的区间，只要 [ k + 1 , m ] 这些区间都合法的话，那么 mmin[ i ] = b[ k ] 的这些位置都是可以在第 k 段上当做起点的位置，且是连续的，因为数据比较大，所以用 map 离散的记一下数</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;string&gt;
#include&lt;ctime&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
using namespace std;
typedef long long LL;
const int inf=0x3f3f3f3f;
const int N=2e5+100;
const int mod=998244353;
int a[N],b[N];
int mmin[N];
map&lt;int,int&gt;cnt;
int main()
{
	int n,m;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,a+i);
	for(int i=1;i&lt;=m;i++)
		scanf(&quot;%d&quot;,b+i);
	mmin[n+1]=inf;
	for(int i=n;i&gt;=1;i--)
	{
		mmin[i]=min(mmin[i+1],a[i]);
		cnt[mmin[i]]++;
	}
	if(mmin[1]!=b[1])
		return 0*puts(&quot;0&quot;);
	LL ans=1;
	for(int i=2;i&lt;=m;i++)
		ans=ans*cnt[b[i]]%mod;
	printf(&quot;%lld\n&quot;,ans);
    return 0;
}
</code></pre>
<p>自己的解法，没想到维护后缀。记录每个b[i]最后出现的位置，从后往前计数，由于b是严格递增的，不需要担心位置重叠问题。但这个方法特判比较多，不像上面那个方法。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
using namespace std;
#define inf 0x7fffffff
#define ll long long
#define maxn 200005
#define mod (998244353)
ll a[maxn], b[maxn], r[maxn];
int main(){
    ll i, n, j, k, t, m, ans=1;
    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);
    for(i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]);
    for(i=1;i&lt;=m;i++) scanf(&quot;%lld&quot;,&amp;b[i]);
    if(m==1){
    	bool f=false;
    	for(i=n;i&gt;=1;i--){
    		if(a[i]&lt;b[1]){
				printf(&quot;0\n&quot;);
				return 0;
			}
			if(a[i]==b[1]) f=true;
		}
		if(f)
		printf(&quot;1\n&quot;);
		else printf(&quot;0\n&quot;);
			return 0;
	}
    ll cur=m;
    for(i=n;i&gt;=1;i--) 
		if(a[i]==b[cur]) r[cur--]=i;
    if(cur){
        printf(&quot;0\n&quot;);
        return 0;
    }
    for(i=r[1];i&gt;=1;i--)
        if(a[i]&lt;b[1]){
            printf(&quot;0\n&quot;);
            return 0;
        }
    for(j=n;j&gt;r[m];j--)
        if(a[j]&lt;b[m]){
            printf(&quot;0\n&quot;);
            return 0;
        }
    for(i=m;i&gt;1;i--){
        for(j=r[i];j&gt;r[i-1];j--) if(a[j]&lt;b[i]) break;
        if(a[j]&lt;a[r[i-1]]){
        	printf(&quot;0\n&quot;);
            return 0;
		} 
        ans=ans*(r[i]-j)%mod;
    }
    printf(&quot;%lld\n&quot;,ans);
}

···
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Round #654 (Div. 2) E Asterism]]></title>
        <id>https://kbxtu.github.io/post/test-one/</id>
        <link href="https://kbxtu.github.io/post/test-one/">
        </link>
        <updated>2020-07-07T04:29:41.000Z</updated>
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1371/problem/E1">传送门</a></p>
<h1 id="题意">题意</h1>
<p>给定长度为n的数组a，表示有n个敌人，第i个敌人有ai颗糖<br>
定义f(x)为：<br>
一开始你有x颗糖，对于长度为n的所有排列，都按照排列的顺序去打敌人当你的糖数量&gt;=怪物的糖数量，那么可以打败敌人，且打败之后你的糖数量+1，f(x)的值就是满足条件的排列数，现在给定一个质数p，要求你找出所有的x，满足f(x)%p!=0<br>
简单版本保证不超过2000<br>
困难版本保证满足条件的x的数量不超过1e5<br>
数据范围：n&lt;=1e5，1&lt;=a(i)&lt;=1e9</p>
<h1 id="e1">E1</h1>
<p>对于简单版本，可以考虑o(n^2)的做法。<br>
设数组a里面的最大值为m，当x&gt;=m时，排列方式为n!，因为p小于等于n，故不满足f(x)%p!=0<br>
当x&lt; m-n+1时，x不能打败最后一个敌人f(x)=0。故m-n+1&lt;=x&lt; m,对a排序后依次判断即可</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
using namespace std;
#define inf 0x7fffffff
#define ll long long
vector&lt;int&gt; ans;
int a[3000],n,p;

int f(int x){
    int ans=1,cur=1;
    for(int i=1;i&lt;=n;i++){
    	for(;cur&lt;=n;cur++){
    		if(x&lt;a[cur]){
            	break;
        	}
		} 
        if((cur-i)%p==0)return 0;
        x++;
    }
    return ans;
}

int main(){
    int i, j, k, t, m;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;p);
    m=0;
    for(i=1;i&lt;=n;i++){
        scanf(&quot;%d&quot;,&amp;a[i]);
    }
    sort(a+1,a+1+n);m=a[n];
    for(i=max(1,m-n+1);i&lt;m;i++){
        if(f(i)) ans.push_back(i);
    }
    k=ans.size();
    printf(&quot;%d\n&quot;,k);
    for(i=0;i&lt;k;i++){
        printf(&quot;%d &quot;,ans[i]);
    }
    printf(&quot;\n&quot;);
}

</code></pre>
<h1 id="e2">E2</h1>
<p>仔细思考可以发现符合条件的x都是连在一起的，即在同一个区间，因为对于排序后的每一个ai，x必须大于等于a[i]-i+1（打败i-1个敌人后能够达到a[i]），故x=max(x,a[i]-i+1),i=1~n。然后由于排列数不能为p的倍数，故每次可排序的数都要小于p,即当x满足a[i]-i+1时，x必须小于a[i+p-1]-i+1，故x=min(x,a[i+p-1]-(i-1)-1)。复杂度为o(n)。</p>
<pre><code>C++
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
using namespace std;
#define inf 0x7fffffff
#define ll long long
ll n, m, p, a[100006];
int main(){
    ll i, j, k, t;
    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;p);
    for(i=1;i&lt;=n;i++){
        scanf(&quot;%lld&quot;,&amp;a[i]);
    }
    ll l=1,r=1e9;
    for(i=1;i&lt;=n;i++) l=max(l,a[i]-i+1);
    for(i=1;i+p-1&lt;=n;i++) r=min(r,a[i+p-1]-i);
    if(l&gt;r) printf(&quot;0\n&quot;);
    else{
        printf(&quot;%lld&quot;,r-l+1);
        for(i=l;i&lt;=r;i++) printf(&quot;%lld &quot;,i);
        printf(&quot;\n&quot;);
    }
}
</code></pre>
]]></content>
    </entry>
</feed>